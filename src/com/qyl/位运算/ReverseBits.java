package com.qyl.位运算;

/**
 * @Author: qyl
 * @Date: 2021/3/29 8:45
 */
public class ReverseBits {

    /**
     * 颠倒 32 位二进制位
     * id: 190
     * level: simple
     * 解法：
     * 预备知识：
     * 逻辑左移 = 算术左移：高位溢出，低位补 0
     * 逻辑右移：低位溢出，高位补 0
     * 算术右移：低位溢出，高位用符号位的值补
     * 比如一个有符号位的 8 位二进制数 10101010，[]是添加的数字
     *
     * 逻辑左移一位：0101010[0]
     * 逻辑左移两位：101010[00]
     *
     * 算术左移一位：0101010[0]
     * 算术左移两位：101010[00]
     *
     * 逻辑右移一位：[0]1010101
     * 逻辑右移两位：[00]101010
     *
     * 算术右移一位：[1]1010101
     * 算术右移两位：[11]101010
     *
     * 算术左移和算术右移主要用来进行有符号数的倍增、减半
     * 逻辑左移和逻辑右移主要用来进行无符号数的倍增、减半
     *
     * 思路：
     * 将 n 视作一个长为 32 的二进制串，从低位往高位枚举 n 的每一位，将其倒序添加到翻转结果 rev 中。
     * 代码实现中，每枚举一位就将 n 右移一位，这样当前 n 的最低位就是我们要枚举的比特位。当 n 为 0 时即可结束循环。
     * 需要注意的是，在某些语言（如 Java）中，没有无符号整数类型，因此对 n 的右移操作应使用逻辑右移。
     * @param n
     * @return
     */
    public int reverseBits(int n) {
        int rev = 0;
        for (int i = 0; i < 32 && n != 0; i++) {
            rev |= (n & 1) << (31 - i);  // n & 1 取n的最低位，rev |= ... 表示接受右边的值
            n >>>= 1;
        }
        return rev;
    }

    public static void main(String[] args) {
        // 101
        // 001
        // 001
        int a = 5;
        System.out.println(a & 1);
    }
}
